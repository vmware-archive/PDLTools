<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="pdltools_extra.css" rel="stylesheet" type="text/css"/>
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-47128600-1', 'auto');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pdl.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">PDL Tools
   &#160;<span id="projectnumber">1.8</span>
   </div>
   <div id="projectbrief">User Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="gettingstarted.html"><span>Getting&#160;Started</span></a></li>
      <li><a href="installpage.html"><span>Installation</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="changelog.html"><span>Change&#160;Log</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction<div class="ingroups"><a class="el" href="group__grp__sugar__framework.html">The SUgAR Framework</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<h1>The SUgAR library</h1>
<h2>Syntactic Up-grade for Analytics Routines</h2>
<p>The SUgAR library is a tool for providing second-order parsing of your SQL command-line, a capability that is much-needed for analytics. With this capability, queries can become easier to write, more reusable and prettier. SUgAR, therefore, provides much more than just syntactic sugaring.</p>
<p>Examples of the power of second-order parsing, as provided by SUgAR, include full-featured pivoting, the ability to write UDWFs (user-defined window functions, a feature currently missing from GPDB) and the ability to easily utilize your own UDFs (user-defined functions) as UDWFs, regardless of the language in which they were implemented.</p>
<p>To perform this, SUgAR provides one main function (<code>'sugar'</code>), two database tables (<code>'sugar_db'</code> and <code>'sugar_help_db'</code>) and several convenience functions.</p>
<p>Use of SUgAR is usually done by providing your desired SQL query as a parameter to the <code>'sugar'</code> function. Such as this:</p>
<pre class="fragment">SELECT sugar('SELECT a FROM generate_series(1,10) a;');
</pre><p>This is known as 'sugar-coating' your query. The reason because of which sugar-coating your query is good, is because it allows your query to include some features not supported by GPDB or not supportable by SQL. For example, even though a window-function called <code>'zscore'</code> is not available in GPDB, and even though UDWFs are not supported in GPDB, with SUgAR you can write your own <code>'zscore'</code> and execute it by running</p>
<pre class="fragment">SELECT sugar($$
  SELECT a, zscore(a) AS z FROM generate_series(1,10) a;
$$);
</pre><p>In fact, SUgAR provides zscoring out of the box, so you can simply use</p>
<pre class="fragment">SELECT sugar($$
  SELECT a, SUGAR_SCHEMA.zscore(a) AS z FROM generate_series(1,10) a;
$$);
</pre><p>where SUGAR_SCHEMA is the schema that SUgAR was installed into.</p>
<p>An important note, however, is that <code>'sugar'</code> SELECT statements do not provide tabular outputs. For this reason, the only reasonable way to use SUgAR is by sending table creation queries as parameters. A common SUgAR idiom is therefore</p>
<pre class="fragment">SELECT sugar($$
  CREATE TABLE outtable AS
    SELECT a, zscore(a) AS z FROM generate_series(1,10) a;
$$);
SELECT * FROM outtable;
</pre><p>We call such SUgAR-supported functions as <code>'zscore'</code> by the name SUgAR functions or pseudofunctions.</p>
<p>Currently supported pseudofunctions are:</p><ul>
<li><em>zscore</em> &ndash; Calculate the z-score (i.e. the standardized variable).</li>
<li><em>pvalue</em> &ndash; Calculate the pvalue (i.e. the cdf of the z-score).</li>
<li><em>normalize</em> &ndash; Translate column values to the range \([0,1]\).</li>
<li><em>proportion</em> &ndash; Normalize the column values to sum to 1.</li>
<li><em>pivot01</em> &ndash; Make 0/1 columns out of a categorical column.</li>
<li><em>pivot</em> &ndash; Cross-tabulate one column according to another.</li>
<li><em>glob</em> &ndash; Glob column names by a pattern.</li>
<li><em>format_glob</em> &ndash; Glob column names by a pattern and transform them. (See <a class="el" href="group__grp__sugar__funcs.html">SUgAR Pseudofunctions</a> for the complete documentation.)</li>
</ul>
<p>Importantly, however, the function <code>'sugar'</code> itself is unaware of any of these extension functions. All <code>'sugar'</code> does is some shallow parsing of the SQL code sent to it, followed by re-dressing of the SQL, as per instructions that are external to the function. All of SUgAR's pseudofunctions are defined in the table <code>'SUGAR_SCHEMA.sugar_db'</code> (see <a class="el" href="group__grp__sugar__db.html">sugar_db (Table)</a>). The complete documentation for SUgAR pseudofunctions is available in the table <code>'SUGAR_SCHEMA.sugar_help_db'</code> (see <a class="el" href="group__grp__sugar__help__db.html">sugar_help_db (Table)</a>). The purpose of this is to make SUgAR 100% extendable. A user wishing to introduce new pseudofunctions merely needs to add their definitions as rows in tables shaped like <code>'SUGAR_SCHEMA.sugar_db'</code> and <code>'SUGAR_SCHEMA.sugar_help_db'</code>. Calls to <code>sugar</code> accept an extra optional parameter <em>user_table</em> that tells <code>sugar</code> to treat the table whose name is <em>user_table</em> as though its rows are extra rows appearing in <code>sugar_db</code> / <code>sugar_help_db</code>. (The existing rows, in addition to providing all of SUgAR's functionality, can be used as examples to work off of.)</p>
<dl class="section warning"><dt>Warning</dt><dd>Never add function definitions directly into <code>sugar_db</code> and <code>sugar_help_db</code>, as such additons will be overwritten and erased next time the library is upgraded.</dd></dl>
<dl class="section user"><dt></dt><dd><h1>AN IMPORTANT NOTE REGARDING SCHEMA QUALIFIERS </h1>
</dd></dl>
<p>By default, all SUgAR's pseudofunctions, exactly like all other functions, must have full schema qualifications. So, for example, one would to use the SUgAR query</p>
<pre class="fragment">  CREATE TABLE outtable AS
    SELECT patient_id AS id, name,
      SUGAR_SCHEMA.pivot(diagnosis_code, patient_table, from_date,
        SUGAR_SCHEMA.unique_element)
    FROM patient_table GROUP BY (id,name)
  DISTRIBUTED BY (id);
</pre><p>rather than</p>
<pre class="fragment">  CREATE TABLE outtable AS
    SELECT patient_id AS id, name,
      pivot(diagnosis_code, patient_table, from_date,
        unique_element)
    FROM patient_table GROUP BY (id,name)
  DISTRIBUTED BY (id);
</pre><p>(on the assumption that SUgAR is installed in the database schema SUGAR_SCHEMA).</p>
<p>This is consistent with the SQL method of keeping the namespace clean. However, it is possible to get SUgAR to recognize both the qualified and the unqualified pseudofunction names. The way to do so is to add SUGAR_SCHEMA to the search_path (again, consistent with standard SQL methods).</p>
<p>Because SUgAR's typing is not consistent with SQL typing, it was not possible for SUgAR's schema resolution to be exactly identical to SQL's. For example, if SUGAR_SCHEMA is on the search_path after another schema that also defines <code>'pivot'</code>, SUgAR would nevertheless treat <code>'pivot'</code> as the SUgAR pseudofunction, rather than the function appearing earlier on the path. The general rule is that SUgAR will only recognize the qualified names if SUGAR_SCHEMA is not on the path, but will recognize both versions of the names if it is on the path. The position of SUGAR_SCHEMA on the path does not change the treatment of pseudofunctions. For the purpose of pseudofunctions, SUGAR_SCHEMA is always treated as the first element on the path. (For regular functions appearing in SUGAR_SCHEMA, standard SQL rules apply, of course.)</p>
<p>Note that in either case, SUgAR's name resolution is case insensitive.</p>
<p>Also note that SUgAR's schema is distinct from the schema housing all other PDL Tools functionality.</p>
<dl class="section user"><dt></dt><dd><h1>Additional features of the <code>'sugar'</code> function </h1>
</dd></dl>
<p><code>"@"</code>: Use <code>@(x,w)</code> to return column <code>x</code> values inside window <code>w</code> as an array. (The order of <code>x</code> values in the array is not guaranteed, but it will be consistent for a given choice of <code>w</code> within a single query. The function can also be used without <code>w</code>. As a single argument function, it also works without parentheses: <code>"@x"</code>. This uses <code>DEFAULT_WINDOW</code> as the window. If <code>DEFAULT_WINDOW</code> is not defined, <code>"@x"</code> works as an aggregate. This pseudo-aggregate, essentially a faster version of <code>array_agg</code>, allows one to easily make one's UDFs into window functions, by having them take results of <code>@(x,w)</code> [or <code>@x</code>] as parameters.</p>
<dl class="section user"><dt>Examples</dt><dd><pre class="fragment">  CREATE TABLE test_data
  (fyear integer,firm float8,eps float8);
  
  INSERT INTO test_data
  SELECT (b.f + 1) % 10 + 2000 AS fyear,
  floor((b.f+1)/10) + 50 AS firm,
  f::float8/100 + random()/10 AS eps
  FROM generate_series(-500,499,1) b(f);
  
  -- find slope of the linear model regression line
  CREATE OR REPLACE FUNCTION r_regr_slope(x float8[], y float8[])
  RETURNS float8 AS $BODY$
  slope &lt;- NA
  if (length(x)==9) try (slope &lt;- lm(y ~ x)$coefficients[2])
  return(slope)
  $BODY$ LANGUAGE plr;
  
  -- Use the function as follows
  DROP TABLE IF EXISTS outtable;
  
  SELECT sugar($SUGAR$
    CREATE TABLE outtable AS
      SELECT *, r_regr_slope(@eps, @lag_eps) AS slope_R FROM (
        SELECT firm, fyear, eps,
               lag(eps) OVER (
                 PARTITION BY firm ORDER BY firm, fyear
               ) AS lag_eps
        FROM test_data
      ) AS a
      WHERE eps IS NOT NULL AND lag_eps IS NOT NULL
      WINDOW default_window AS (
        PARTITION BY firm ORDER BY firm, fyear ROWS 8 PRECEDING
      )
      DISTRIBUTED BY (fyear);
  $SUGAR$);
</pre></dd></dl>
<p>Note that the operator precedence of <code>'@'</code> is fairly low, so <code>'@x+3'</code> is the same as <code>'@(x+3)'</code>. This is usually the desired behavior. If the reverse behavior is required, one can always use parentheses: <code>'@(x)+3'</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The SUgAR <code>'@'</code> operator conflicts with the standard PostgreSQL <code>'@'</code> denoting absolute value. When using SUgAR, denote absolute value taking by <code><a class="el" href="complex__type_8sql__in.html#a649879fd77f405417288b05c458c791f">abs()</a></code>, instead.</dd></dl>
<dl class="section user"><dt></dt><dd><h1>Additional convenience functions in SUgAR (all in the SUGAR_SCHEMA schema) </h1>
</dd></dl>
<pre class="syntax">
AGGREGATE choose_any(x);
</pre><p>is an aggregate function, returning an arbitrary value from column <em>x</em>. It's guaranteed to return a non-null value if one exists.</p>
<pre class="syntax">
AGGREGATE unique_element(x);
</pre><p>is an aggregate function that returns the unique non-NULL value from column <em>x</em> or raises an exception if it is not unique.</p>
<p>Both <code>"choose_any"</code> and <code>"unique_element"</code> are useful as pivoting aggregates. The default <code>pivot</code> aggregation parameter is <code>"unique_element"</code>.</p>
<pre class="syntax">
FUNCTION <a class="el" href="group__grp__all__vals.html">all_vals</a> RETURNS TEXT;
</pre><pre class="syntax">
FUNCTION <a class="el" href="group__grp__freq__vals.html">freq_vals</a> RETURNS TEXT;
</pre><pre class="syntax">
FUNCTION <a class="el" href="group__grp__all__but__one.html">all_but_one</a> RETURNS TEXT;
</pre><p>These are convenience functions for <code>pivot</code>/<code>pivot01</code>. They can be used as the <em>colchoice</em> parameter for pivoting. It is easy to create more such functions for other needs. See these functions for more documentation, as well as <a class="el" href="group__grp__pivot.html">pivot (Pseudo-aggregate)</a> and <a class="el" href="group__grp__pivot01.html">pivot01 (Pseudofunction)</a>.</p>
<p>Other convenience functions available in SUgAR are</p>
<pre class="syntax">
FUNCTION proportional_trans(x,a,b);
</pre><p>which returns \(x*a+b\),</p>
<pre class="syntax">
FUNCTION invprop_trans(x,a,b);
</pre><p>which returns \((x-b)/a\), and</p>
<pre class="syntax">
FUNCTION clamp(x,minval,maxval);
</pre><p>which returns \( \text{GREATEST}(\text{LEAST}(x,\textit{maxval}),\textit{minval}) \).</p>
<h1>Getting Help on SUgAR and the <code>'sugar'</code> function </h1>
<p>All SQL functions in the SUGAR_SCHEMA schema (except <code>'sugar_version()'</code>, aggregate functions and internal functions) can be called with no parameters or with the parameter '' for a brief usage message (unless this conflicts with their regular functionality), as well as with the single textual parameter <code>'usage'</code> for their full documentation. In particular, this is true for <code>'sugar'</code>, the main function of the SUgAR library.</p>
<p>The following are additional methods to get help regarding the SUgAR library, the <code>'sugar'</code> function and the SUgAR pseudofunctions.</p>
<pre class="example">
SELECT sugar();
SELECT sugar('');
</pre><p> A brief description of the <code>'sugar'</code> function, including how to get further help.</p>
<pre class="example">
SELECT sugar('about');
</pre><p> Overview of the SUgAR library.</p>
<pre class="example">
SELECT sugar('list' [, '<em>func_pattern'</em> [, '<em>user_table'</em>] ]);
</pre><p> Listing of the various SUgAR pseudofunctions supported, with a brief apropos-style description of each. (Note that this function lists only pseudofunctions, not regular SQL functions. So, for example, to get help on the SQL function <code>'proportional_trans'</code>, use <code>"SELECT proportional_trans('usage');"</code>, instead. All (non-aggregate) SQL functions in the SUgAR library provide help when invoked with either no parameters or with the single textual parameter <code>'usage'</code>.) The optional argument '<em>func_pattern'</em> is a pattern (possibly simply being the name of a pseudofunction). If given, the function only returns information about SUgAR pseudofunctions matching the pattern. The supported pattern format is the PostgreSQL <code>'LIKE'</code>. If omitted, <em>func_pattern</em> defaults to '' (all pseudofunctions). The optional parameter <em>user_table</em> is the name of a table with the same format as <em>sugar_help_db</em>. If used, rows in <em>user_table</em> are treated as though they have been appended to <em>sugar_help_db</em>.</p>
<pre class="example">
SELECT sugar('usage');
</pre><p> A full description of the <code>'sugar'</code> function, including usage examples.</p>
<pre class="example">
SELECT sugar('usage','<em>funcname'</em> [, '<em>user_table'</em>]);
</pre><p> Get usage help on any particular pseduofunction. (In this case: <em>funcname</em>.) Use <code>"SELECT sugar('usage','sugar_db');"</code> and <code>"SELECT sugar('usage','sugar_help_db');"</code> to get usage help regarding the two database tables used by SUgAR and how to use these in order to write your own SUgAR extensions. The optional parameter <em>user_table</em> is the name of a table with the same format as <em>sugar_help_db</em>. If used, rows in <em>user_table</em> are treated as though they have been appended to <em>sugar_help_db</em>.</p>
<pre class="example">
SELECT sugar_version();
</pre><p> Get the version-string describing the version number of the SUgAR library.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__grp__sugar.html" title="SUgAR: Syntactic Up-grade for Analytic Routines. ">sugar</a> </dd></dl>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.nl/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
